diff -Naur old/openvpn-2.4.6/src/openvpn/forward.c new/openvpn-2.4.6/src/openvpn/forward.c
--- old/openvpn-2.4.6/src/openvpn/forward.c	2018-04-24 15:12:55.000000000 +0800
+++ new/openvpn-2.4.6/src/openvpn/forward.c	2019-07-26 13:38:34.076003300 +0800
@@ -50,6 +50,109 @@
 counter_type link_read_bytes_global;  /* GLOBAL */
 counter_type link_write_bytes_global; /* GLOBAL */
 
+/* Foxconn added start */
+#define IPcountry_lookup "/tmp/IPcountry_lookup"
+#define Route_country_lookup "/tmp/Router_country_lookup"
+
+int
+route_country_lookup(void)
+{
+	char buff[256],debug[1024];
+	FILE *fp;
+
+	//sprintf(buff,"/usr/bin/geoiplookup -f /usr/share/GeoIP/GeoIP.dat %s >> /tmp/IPcountry_lookup",IPfrom);
+	sprintf(buff,"wget \"http://www.speedtest.net/api/country\" -O /tmp/Router_country_lookup");
+
+	sprintf(debug,"echo '##########%s(%d)buff=%s' > /dev/console",__func__,__LINE__,buff);
+	//system(debug);
+
+	system(buff);
+	sleep(5);
+
+	fp = fopen(Route_country_lookup, "r");
+    if (fp)
+    {
+        fgets(buff, sizeof(buff), fp);
+		if(strcmp(buff,"") == 0){
+			sprintf(debug,"echo '[OpenVPN]route_country_lookup() failed' > /dev/console");
+			system(debug);
+		}
+			
+		//sprintf(debug,"echo '##########ip_country_lookup() %s' > /dev/console",buff);
+		//system(debug);
+        fclose(fp);
+    }else{
+    	sprintf(debug,"echo '[OpenVPN]route_country_lookup() connection failed' > /dev/console");
+		system(debug);
+    }
+
+	if(strstr(buff,"US") != 0){
+		//IP address from US
+		return 1;
+	}else if((strstr(buff,"EU") != 0) || (strstr(buff,"FR") != 0) || (strstr(buff,"GB") != 0) || (strstr(buff,"DE") != 0) || (strstr(buff,"IT") != 0)){
+		//IP address from Europe,France, UK, Germary
+		return 2;
+	}
+
+	//unlink(Route_country_lookup);
+
+	return 0;
+
+
+	
+}//allenwen Foxconn
+
+
+int
+ip_country_lookup(char *IPfrom)
+{
+	char buff[256],debug[1024];
+	FILE *fp;
+
+	//sprintf(buff,"/usr/bin/geoiplookup -f /usr/share/GeoIP/GeoIP.dat %s >> /tmp/IPcountry_lookup",IPfrom);
+	sprintf(buff,"wget \"http://www.speedtest.net/api/country?ip=%s\" -O /tmp/IPcountry_lookup",IPfrom);
+
+	sprintf(debug,"echo '##########%s(%d)buff=%s' > /dev/console",__func__,__LINE__,buff);
+	//system(debug);
+
+	system(buff);
+	sleep(5);
+
+	fp = fopen(IPcountry_lookup, "r");
+    if (fp)
+    {
+        fgets(buff, sizeof(buff), fp);
+		if(strcmp(buff,"") == 0){
+			sprintf(debug,"echo '[OpenVPN]ip_country_lookup() failed' > /dev/console");
+			system(debug);
+		}
+			
+		//sprintf(debug,"echo '##########ip_country_lookup() %s' > /dev/console",buff);
+		//system(debug);
+        fclose(fp);
+    }else{
+    	sprintf(debug,"echo '[OpenVPN]ip_country_lookup() connection failed' > /dev/console");
+		system(debug);
+    }
+
+	if((strstr(buff,"US") != 0) || (strstr(buff,"CA") != 0)){
+		//IP address from US
+		return 1;
+	}else if((strstr(buff,"EU") != 0) || (strstr(buff,"FR") != 0) || (strstr(buff,"GB") != 0) || (strstr(buff,"DE") != 0) || (strstr(buff,"IT") != 0)){
+		//IP address from Europe,France, UK, Germary
+		return 2;
+	}
+
+	//unlink(IPcountry_lookup);
+
+	return 0;
+
+
+	
+}//allenwen Foxconn
+/* Foxconn added end */
+
+
 /* show event wait debugging info */
 
 #ifdef ENABLE_DEBUG
@@ -253,7 +356,93 @@
     {
         struct gc_arena gc = gc_new();
         bool stat;
-
+	/* Foxconn modify start, Max Ding, 04/19/2014 OpenVPN: support tun and tap at the same time */
+	//char command[1024];
+	char tmp[1024];
+	int ipfrom, route_country;
+	char lanip[64]="";
+	char lannetmask[64]="";
+	char mode[32]="";
+	FILE *pPipe = NULL;
+	char cmd[256];
+
+	//sprintf(command,"echo '##########send_control_channel_string()1 str=%s' > /dev/console",str);
+	//system(command);
+
+	if(strstr(str,"PUSH_REPLY") != 0){
+	    
+	    sprintf(cmd, "nvram get lan_ipaddr");
+	    if ((pPipe = popen (cmd, "r")) != NULL)
+	    {
+	        fgets (lanip, 63, pPipe);
+	        feof (pPipe);
+	        pclose (pPipe);
+	    }
+	    
+	    sprintf(cmd, "nvram get lan_netmask");
+	    if ((pPipe = popen (cmd, "r")) != NULL)
+	    {
+	        fgets (lannetmask, 63, pPipe);
+	        feof (pPipe);
+	        pclose (pPipe);
+	    }
+
+	    sprintf(cmd, "nvram get openvpn_redirectGW");
+	    if ((pPipe = popen (cmd, "r")) != NULL)
+	    {
+	        fgets (mode, 31, pPipe);
+	        feof (pPipe);
+	        pclose (pPipe);
+	    }
+
+
+		if(strcmp(mode,"auto") == 0){
+			//memset(str, 0, sizeof(str));
+
+			route_country = route_country_lookup();
+
+			ipfrom = ip_country_lookup(inet_ntoa (c->c2.to_link_addr->dest.addr.in4.sin_addr));
+
+			if((ipfrom != route_country) && (route_country == 2)){//NA to Europe
+				//sprintf(str,"PUSH_REPLY,route %s %s %s,route 57.0.0.0 255.0.0.0 %s,route 90.0.0.0 255.128.0.0 %s,route 78.192.0.0 255.192.0.0 %s,route 92.128.0.0 255.192.0.0 %s,route 86.192.0.0 255.192.0.0 %s,route 176.128.0.0 255.192.0.0 %s,route 25.0.0.0 255.0.0.0 %s,route 51.0.0.0 255.0.0.0 %s,route 86.128.0.0 255.192.0.0 %s,route 53.0.0.0 255.0.0.0 %s,route 84.128.0.0 255.192.0.0 %s,route 93.192.0.0 255.192.0.0 %s,route 176.0.0.0 255.192.0.0 %s,route 151.3.0.0 255.128.0.0 %s,route-gateway dhcp,ping 10,ping-restart 120\0",lanip,lannetmask,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip);
+				sprintf(tmp,",route %s %s %s,route 57.0.0.0 255.0.0.0 %s,route 90.0.0.0 255.128.0.0 %s,route 78.192.0.0 255.192.0.0 %s,route 92.128.0.0 255.192.0.0 %s,route 86.192.0.0 255.192.0.0 %s,route 176.128.0.0 255.192.0.0 %s,route 25.0.0.0 255.0.0.0 %s,route 51.0.0.0 255.0.0.0 %s,route 86.128.0.0 255.192.0.0 %s,route 53.0.0.0 255.0.0.0 %s,route 84.128.0.0 255.192.0.0 %s,route 93.192.0.0 255.192.0.0 %s,route 176.0.0.0 255.192.0.0 %s,route 151.3.0.0 255.128.0.0 %s\0",
+						lanip,lannetmask,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip);
+				strcat(str, tmp);
+			}else if((ipfrom != route_country) && (route_country == 1)){//Europe to NA(north american)
+				//sprintf(str,"PUSH_REPLY,route %s %s %s,route 3.0.0.0 255.0.0.0 %s,route 4.0.0.0 255.0.0.0 %s,route 8.0.0.0 255.0.0.0 %s,route 9.0.0.0 255.0.0.0 %s,route 14.0.0.0 255.0.0.0 %s,route 16.0.0.0 255.0.0.0 %s,route 18.0.0.0 255.0.0.0 %s,route 23.0.0.0 255.0.0.0 %s,route 47.128.0.0 255.128.0.0 %s,route 54.0.0.0 255.0.0.0 %s,route 184.0.0.0 255.0.0.0 %s,route 69.0.0.0 255.0.0.0 %s,route 204.245.0.0 255.255.0.0 %s,route 173.224.0.0 255.255.0.0 %s,route-gateway dhcp,ping 10,ping-restart 120\0",lanip,lannetmask,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip);
+				sprintf(tmp,",route %s %s %s,route 3.0.0.0 255.0.0.0 %s,route 4.0.0.0 255.0.0.0 %s,route 8.0.0.0 255.0.0.0 %s,route 9.0.0.0 255.0.0.0 %s,route 14.0.0.0 255.0.0.0 %s,route 16.0.0.0 255.0.0.0 %s,route 18.0.0.0 255.0.0.0 %s,route 23.0.0.0 255.0.0.0 %s,route 47.128.0.0 255.128.0.0 %s,route 54.0.0.0 255.0.0.0 %s,route 184.0.0.0 255.0.0.0 %s,route 69.0.0.0 255.0.0.0 %s,route 204.245.0.0 255.255.0.0 %s,route 173.224.0.0 255.255.0.0 %s\0",
+						lanip,lannetmask,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip,lanip);
+				strcat(str, tmp);
+			}
+			else{
+				//	sprintf(str,"PUSH_REPLY,route %s %s %s,route-gateway dhcp,ping 10,ping-restart 120\0",lanip,lannetmask,lanip);
+				sprintf(tmp,",route %s %s %s\0",
+						lanip,lannetmask,lanip);
+				strcat(str, tmp);
+			}
+
+#if 0
+			if(ipfrom == 0){
+				sprintf(command,"echo '##########ipfrom == 0' > /dev/console");
+				system(command);
+			}
+
+			if(route_country == 0){
+				sprintf(command,"echo '##########route_country == 0' > /dev/console");
+				system(command);
+			}
+#endif
+			
+			//sprintf(str,"PUSH_REPLY,route 192.168.1.0 255.255.255.0 192.168.1.1,route 88.0.0.0 255.255.255.0 192.168.1.1,route-gateway dhcp,ping 10,ping-restart 120\0");
+			//sprintf(command,"echo '##########send_control_channel_string() str=%s' > /dev/console",str);
+			//system(command);
+		}//allenwen
+		else if (strcmp("mode", "onlylan") == 0){
+			sprintf(tmp,",route %s %s %s\0", lanip,lannetmask,lanip);
+			strcat(str, tmp);
+		}
+	}
+	/* Foxconn modify end, Max Ding, 04/19/2014 */
         /* buffered cleartext write onto TLS control channel */
         stat = tls_send_payload(c->c2.tls_multi, (uint8_t *) str, strlen(str) + 1);
 
@@ -536,6 +725,7 @@
 static void
 process_coarse_timers(struct context *c)
 {
+	char foxconn_log[512];  
 #ifdef ENABLE_CRYPTO
     /* flush current packet-id to file once per 60
      * seconds if --replay-persist was specified */
@@ -569,6 +759,11 @@
 
     /* restart if ping not received */
     check_ping_restart(c);
+  if(c->sig->signal_received == SIGUSR1){
+	sprintf(foxconn_log, "[OpenVPN, connection drop] from remote IP address:%s",inet_ntoa (c->c2.to_link_addr->dest.addr.in4.sin_addr));
+	//ambitWriteLog(foxconn_log, sizeof(foxconn_log));
+    ambitWriteLog(foxconn_log, strlen(foxconn_log)); // JAG-205 There are many error log when failed to connect VPN connection. 
+  }
     if (c->sig->signal_received)
     {
         return;
diff -Naur old/openvpn-2.4.6/src/openvpn/init.c new/openvpn-2.4.6/src/openvpn/init.c
--- old/openvpn-2.4.6/src/openvpn/init.c	2018-04-24 15:12:55.000000000 +0800
+++ new/openvpn-2.4.6/src/openvpn/init.c	2019-07-26 08:34:56.016252400 +0800
@@ -62,6 +62,24 @@
 #define CF_LOAD_PERSISTED_PACKET_ID (1<<0)
 #define CF_INIT_TLS_MULTI           (1<<1)
 #define CF_INIT_TLS_AUTH_STANDALONE (1<<2)
+/* foxconn added start */
+int ambitWriteLog(char *pcLog, int iLen)
+{
+        FILE *fp;
+
+	//system("echo '##########ambitWriteLog()step1' > /dev/console");
+	if (!(fp = fopen("/dev/aglog", "r+")))
+        {
+              printf("%s:open /dev/aglog fail\n", __FUNCTION__);
+              return -1;
+        }
+
+    	*(pcLog + iLen) = '\0';
+        fwrite(pcLog, sizeof(char), iLen+1, fp);
+        fclose(fp);
+        return 0;
+}
+/* foxconn added end */
 
 static void do_init_first_time(struct context *c);
 
diff -Naur old/openvpn-2.4.6/src/openvpn/multi.c new/openvpn-2.4.6/src/openvpn/multi.c
--- old/openvpn-2.4.6/src/openvpn/multi.c	2018-04-24 15:12:55.000000000 +0800
+++ new/openvpn-2.4.6/src/openvpn/multi.c	2019-07-26 12:25:23.028533300 +0800
@@ -49,6 +49,8 @@
 
 #include "forward-inline.h"
 #include "pf-inline.h"
+#include <netinet/in.h> // foxconn add
+#include <mroute.h> // foxconn add
 
 /*#define MULTI_DEBUG_EVENT_LOOP*/
 
@@ -885,12 +887,16 @@
 
                 if (!mi->halt)
                 {
-                    status_printf(so, "%s,%s," counter_format "," counter_format ",%s",
-                                  tls_common_name(mi->context.c2.tls_multi, false),
-                                  mroute_addr_print(&mi->real, &gc),
-                                  mi->context.c2.link_read_bytes,
-                                  mi->context.c2.link_write_bytes,
-                                  time_string(mi->created, 0, false, &gc));
+		  /* Foxconn modify start, Max Ding, 04/10/2014 for attached device display */
+		  status_printf (so, "%s,%s," counter_format "," counter_format ",0x%x,0x%x,%s",
+				 tls_common_name (mi->context.c2.tls_multi, false),
+				 mroute_addr_print (&mi->real, &gc),
+				 mi->context.c2.link_read_bytes,
+				 mi->context.c2.link_write_bytes,
+				 mi->reporting_addr,
+				 mi->created,
+				 time_string (mi->created, 0, false, &gc));
+		  /* Foxconn modify end, Max Ding, 04/10/2014 */
                 }
                 gc_free(&gc);
             }
@@ -2478,6 +2484,25 @@
     gc_free(&gc);
 }
 
+/* Foxconn add start, Max Ding, 04/10/2014 OpenVPN: support tun and tap at the same time */
+static inline bool
+mroute_is_bcast (struct mroute_addr *da, in_addr_t bcast_addr)
+{
+	in_addr_t dest_addr;
+	if ((da->type & MR_ADDR_MASK) == MR_ADDR_IPV4)
+	{
+		dest_addr = ntohl(*(in_addr_t*)da->raw_addr);
+		if (dest_addr == 0xffffffff)
+			return true;
+		if (dest_addr == bcast_addr) /* e.g. 192.168.2.255/24 */
+			return true;
+	}
+	return false;
+}
+/* Foxconn add end, Max Ding, 04/10/2014 */
+
+
+
 /*
  * Process packets in the TCP/UDP socket -> TUN/TAP interface direction,
  * i.e. client -> server direction.
@@ -2560,6 +2585,10 @@
                                                                NULL,
                                                                &c->c2.to_tun,
                                                                DEV_TYPE_TUN);
+		  /* Foxconn add start, Max Ding, 04/10/2014 OpenVPN: support tun and tap at the same time */
+		  if (mroute_is_bcast(&dest, m->top.c1.tuntap->local |(~m->top.c1.tuntap->remote_netmask)))
+			   mroute_flags |= MROUTE_EXTRACT_MCAST;
+		  /* Foxconn add end, Max Ding, 04/10/2014 */
 
                 /* drop packet if extract failed */
                 if (!(mroute_flags & MROUTE_EXTRACT_SUCCEEDED))
@@ -2763,6 +2792,10 @@
                                                        NULL,
                                                        &m->top.c2.buf,
                                                        dev_type);
+	  /* Foxconn add start, Max Ding, 04/10/2014 OpenVPN: support tun and tap at the same time */
+	  if (mroute_is_bcast(&dest, m->top.c1.tuntap->local |(~m->top.c1.tuntap->remote_netmask)))
+		   mroute_flags |= MROUTE_EXTRACT_MCAST;
+	  /* Foxconn add end, Max Ding, 04/10/2014 */
 
         if (mroute_flags & MROUTE_EXTRACT_SUCCEEDED)
         {
@@ -3070,9 +3103,12 @@
 {
     if (m->top.sig->signal_received == SIGUSR2)
     {
-        struct status_output *so = status_open(NULL, 0, M_INFO, NULL, 0);
-        multi_print_status(m, so, m->status_file_version);
-        status_close(so);
+      /* Foxconn modify start, Max Ding, 04/10/2014 OpenVPN: support tun and tap at the same time */
+      //struct status_output *so = status_open (NULL, 0, M_INFO, NULL, 0);
+      //multi_print_status (m, so, m->status_file_version);
+      //status_close (so);
+      multi_print_status (m, m->top.c1.status_output, m->status_file_version);
+      /* Foxconn modify end, Max Ding, 04/10/2014 */
         m->top.sig->signal_received = 0;
         return false;
     }
diff -Naur old/openvpn-2.4.6/src/openvpn/push.c new/openvpn-2.4.6/src/openvpn/push.c
--- old/openvpn-2.4.6/src/openvpn/push.c	2018-04-24 15:12:52.000000000 +0800
+++ new/openvpn-2.4.6/src/openvpn/push.c	2019-07-26 09:10:56.145038200 +0800
@@ -458,6 +458,12 @@
     const int extra = 84; /* extra space for possible trailing ifconfig and push-continuation */
     const int safe_cap = BCAP(&buf) - extra;
     bool push_sent = false;
+	char foxconn_log[512];
+
+    sprintf(foxconn_log, "[OpenVPN, connection successfully] from remote IP address:%s",inet_ntoa (c->c2.to_link_addr->dest.addr.in4.sin_addr));
+    //ambitWriteLog(foxconn_log, sizeof(foxconn_log));//allenwen add openvpn log
+    ambitWriteLog(foxconn_log, strlen(foxconn_log)); // JAG-205 There are many error log when failed to connect VPN connection. 
+
 
     buf_printf(&buf, "%s", push_reply_cmd);
 
diff -Naur old/openvpn-2.4.6/src/openvpn/ssl.c new/openvpn-2.4.6/src/openvpn/ssl.c
--- old/openvpn-2.4.6/src/openvpn/ssl.c	2018-04-24 15:12:55.000000000 +0800
+++ new/openvpn-2.4.6/src/openvpn/ssl.c	2019-07-26 09:12:28.879093700 +0800
@@ -2726,6 +2726,7 @@
     bool active = false;
     struct key_state *ks = &session->key[KS_PRIMARY];      /* primary key */
     struct key_state *ks_lame = &session->key[KS_LAME_DUCK]; /* retiring key */
+  char foxconn_log[512];
 
     /* Make sure we were initialized and that we're not in an error state */
     ASSERT(ks->state != S_UNDEF);
@@ -3107,7 +3108,12 @@
     tls_clear_error();
     ks->state = S_ERROR;
     msg(D_TLS_ERRORS, "TLS Error: TLS handshake failed");
-    INCR_ERROR;
+    /* foxconn added start */
+    sprintf(foxconn_log, "[OpenVPN, connection fail] from reomote IP address:%s",inet_ntoa (ks->remote_addr.dest.addr.in4.sin_addr));
+    //ambitWriteLog(foxconn_log, sizeof(foxconn_log));
+    ambitWriteLog(foxconn_log, strlen(foxconn_log)); // JAG-205 There are many error log when failed to connect VPN connection.
+    /* foxconn added end */
+	INCR_ERROR;
     gc_free(&gc);
     return false;
 }
diff -Naur old/openvpn-2.4.6/src/openvpn/syshead.h new/openvpn-2.4.6/src/openvpn/syshead.h
--- old/openvpn-2.4.6/src/openvpn/syshead.h	2018-04-24 15:12:55.000000000 +0800
+++ new/openvpn-2.4.6/src/openvpn/syshead.h	2019-07-26 09:12:57.731675500 +0800
@@ -703,4 +703,5 @@
 #define ENABLE_MEMSTATS
 #endif
 
+extern int ambitWriteLog(char *pcLog, int iLen);//foxconn add for openvpn log
 #endif /* ifndef SYSHEAD_H */
